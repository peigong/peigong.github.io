<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LocalAd周培公</title>
    <description>化尽情缘修古寺，扫遍佛塔入天山。
</description>
    <link>http://www.peigong.net/</link>
    <atom:link href="http://www.peigong.net/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 28 Aug 2014 08:29:41 +0800</pubDate>
    <lastBuildDate>Thu, 28 Aug 2014 08:29:41 +0800</lastBuildDate>
    <generator>Jekyll v2.3.0</generator>
    
      <item>
        <title>读内经校释</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;2013-08-11&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;少年也曾常读书，&lt;/p&gt;

&lt;p&gt;自命古人亦能穷。&lt;/p&gt;

&lt;p&gt;至今人生多感悟，&lt;/p&gt;

&lt;p&gt;欣慰一二与人同。&lt;/p&gt;
</description>
        <pubDate>Sat, 11 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://www.peigong.net/articles/read/nei-jing.html</link>
        <guid isPermaLink="true">http://www.peigong.net/articles/read/nei-jing.html</guid>
        
        
        <category>read</category>
        
      </item>
    
      <item>
        <title>CentOS下安装git和配置git服务器</title>
        <description>
&lt;p&gt;在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。&lt;/p&gt;

&lt;p&gt;GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。&lt;/p&gt;

&lt;p&gt;搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或CentOS，这样，通过几条简单的apt或yum命令就可以完成安装。&lt;/p&gt;

&lt;p&gt;假设你已经有sudo权限的用户账号，下面，正式开始安装。&lt;/p&gt;

&lt;h3 id=&quot;git&quot;&gt;第一步，安装git：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;yum install curl curl-devel zlib-devel openssl-devel perl cpio expat-devel gettext-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载最新的git包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://www.codemonkey.org.uk/projects/git-snapshots/git/git-latest.tar.gz
tar xzvf git-latest.tar.gz
cd git-2011-11-30 ＃你的目录可能不是这个
autoconf
./configure --prefix=/usr/local/git
make
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;检查下安装的版本，大功告成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git --version
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;gitgit&quot;&gt;第二步，创建一个git用户，用来运行git服务：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ sudo adduser git
$ git config --global user.name &quot;whdsmile&quot;
$ git config --global user.email &quot;whdsmile@gmail.com&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;第三步，创建证书登录：&lt;/h3&gt;

&lt;p&gt;收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。&lt;/p&gt;

&lt;h3 id=&quot;git-1&quot;&gt;第四步，初始化Git仓库：&lt;/h3&gt;

&lt;p&gt;先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo git init --bare sample.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：&lt;/p&gt;

&lt;p&gt;$ sudo chown -R git:git sample.git&lt;/p&gt;

&lt;h3 id=&quot;shell&quot;&gt;第五步，禁用shell登录：&lt;/h3&gt;

&lt;p&gt;出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git:x:1001:1001:,,,:/home/git:/bin/bash
改为：
git:x:1001:1001:,,,:/home/git:/usr/local/git/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;srvsamplegittest&quot;&gt;第六步，在/srv/sample.git目录下，假设有一个test目录：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ git add test
$ git commit -m &quot;add file&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;第七步，在开发机上克隆远程仓库：&lt;/h3&gt;

&lt;p&gt;现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git@server:/srv/sample.git

Cloning into &#39;sample&#39;...
warning: You appear to have cloned an empty repository. 剩下的推送就简单了。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;管理公钥
如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。&lt;/p&gt;

&lt;p&gt;这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;参考资料&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://clientlab.github.io/lessons/2014/02/22/TortoiseGit-andl-msysGit-for-gitlab/&quot;&gt;GitLab和TortoiseGit、msysGit的配合使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 09 Jun 2014 00:00:00 +0800</pubDate>
        <link>http://www.peigong.net/articles/lessons/CentOS-git-setup.html</link>
        <guid isPermaLink="true">http://www.peigong.net/articles/lessons/CentOS-git-setup.html</guid>
        
        <category>开发工具</category>
        
        
        <category>lessons</category>
        
      </item>
    
      <item>
        <title>学习OpenX广告管理与跟踪系统</title>
        <description>
&lt;blockquote&gt;
  &lt;p&gt;OpenX Ad Server (简称OpenX )是一个采用PHP开发的广告管理与跟踪系统。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;安装和部署&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;配置要求&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;支持PHP&lt;/li&gt;
  &lt;li&gt;支持MySql&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;下载源代码&lt;/h3&gt;

&lt;p&gt;从&lt;a href=&quot;http://www.openxconsultant.com/blog/2013/08/openx-source-v2-8-11-released-for-download/&quot;&gt;http://www.openxconsultant.com/blog/2013/08/openx-source-v2-8-11-released-for-download/&lt;/a&gt;下载源代码，或者先从&lt;a href=&quot;http://www.openxconsultant.com/blog/category/featured/&quot;&gt;http://www.openxconsultant.com/blog/category/featured/&lt;/a&gt;检查最新发布。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;如果研究学习源代码，可以使用SVN检出，地址：https://svn.openx.org/openx/tags/2.8/openx-2.8.11/&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;安装部署&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;将下载的源代码命名为“openx”，上传到WEB服务器的根目录下。&lt;/li&gt;
  &lt;li&gt;给var、plugins、www/admin/plugins、/www/images子目录赋予写权限。&lt;/li&gt;
  &lt;li&gt;在浏览器中访问http://{yourdomain}/openx，进入到OpenX的安装界面。&lt;/li&gt;
  &lt;li&gt;根据提示信息设置数据库配置和管理员配置。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;选择中文简体，会出现一些乱码问题，建议采用命名和语言版本均以英文为主。时区可以选择Asia/Shanghai。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;基本的操作和使用&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;基础概念&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Advertisers：广告主&lt;/li&gt;
  &lt;li&gt;Campaigns：广告活动&lt;/li&gt;
  &lt;li&gt;Banners：广告&lt;/li&gt;
  &lt;li&gt;Websites：网站&lt;/li&gt;
  &lt;li&gt;Zones：广告位&lt;/li&gt;
  &lt;li&gt;Targeting Channels：目标频道&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-6&quot;&gt;基本操作步骤&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;添加广告主。例如：京东商城&lt;/li&gt;
  &lt;li&gt;为广告主添加广告活动。例如：节日大促&lt;/li&gt;
  &lt;li&gt;添加广告。例如：广告 980 X 90&lt;/li&gt;
  &lt;li&gt;添加网站。例如：http://www.uuu.com &lt;/li&gt;
  &lt;li&gt;添加广告位。例如：广告位 980 X 90&lt;/li&gt;
  &lt;li&gt;链接广告到广告位&lt;/li&gt;
  &lt;li&gt;复制广告位代码到网站&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-7&quot;&gt;添加广告主&lt;/h3&gt;

&lt;p&gt;登录系统后，进入Inventory &amp;gt; Advertisers。&lt;/p&gt;

&lt;p&gt;选择添加新广告主（Add new advertiser），进入添加新广告主界面。&lt;/p&gt;

&lt;p&gt;填写广告主的基本信息（Basic information）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;名称（Name）: 广告主名称必须唯一，广告主名称不能相同。 这里我们写“京东商城”&lt;/li&gt;
  &lt;li&gt;联系人（Contact）: 联系人将被用在所有给广告主的邮件里。&lt;/li&gt;
  &lt;li&gt;邮箱（Email）: 必填项，广告主的邮箱 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在广告主报告（Advertiser report）区域，选择什么条件以及什么时间下需要给广告主发邮件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当广告计划自动生效或者失效的时候发邮件（Email when a campaign is automatically activated/deactivated）：OpenX会在广告计划生效或者失效的时候给广告主发邮件提醒。如果你不想发送此提醒，可以不选此框。&lt;/li&gt;
  &lt;li&gt;广告计划投放报告邮件（Email campaign delivery reports）： 当您想日常性的给广告主发送报告的时候选择此选择框。默认的设置是每周发送报告给广告主。如果您想修改发送报告的周期（Number of days between campaign delivery reports），只要简单的修改下周期即可。如果您给广告主提供的访问系统的帐号，则不建议发送邮件报告。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他（Miscellaneous）区域可以让您设置广告投放的限制选项：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在一个页面只显示此广告主的一个广告（Display only one banner from this advertiser on a web page）： 限制广告在一个页面上只显示一次。&lt;/li&gt;
  &lt;li&gt;备注（Comments）： 广告主的备注信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;添加广告活动&lt;/h3&gt;

&lt;p&gt;完成广告主(京东商城)创建后，从广告主界面点击添加新广告活动（Add new campaign），系统将会带您到添加新广告活动的界面。&lt;/p&gt;

&lt;p&gt;填写基本信息（Basic information）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;名称（Name）：广告活动名称&lt;/li&gt;
  &lt;li&gt;广告活动的类型（Campaign type）：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下一步是选择广告活动的类型。有三种活动类型可选： &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;合约型（排期）：Contract: 合约型广告计划将会在预订的时间和显示次数内投放。  &lt;/li&gt;
  &lt;li&gt;合约型（买断）：Contract (Exclusive): 买断式的广告计划将会占用所有的显示资源，并且优先级高于所有其他广告计划。&lt;/li&gt;
  &lt;li&gt;剩余抄底：Remnant: 标准的广告计划类型，可以基于特殊的投放限制及时期来进行投放。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;选择好广告计划类型后，可以设置一些其他的内容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;日期：Date: 输入广告计划的开始和结束日期。&lt;/li&gt;
  &lt;li&gt;计费模式：Pricing: 允许您设置广告计划的计费模式（CPM、CPC、APC），费率和展示次数。  &lt;/li&gt;
  &lt;li&gt;广告计划优先级：Priority in relation to other campaigns: 默认的优先级为5. 优先级设置级别在1到10之间（10代表优先级最高），如果需要的话，可以设置每天投放的PV/Click或者转换的限额Set   &lt;/li&gt;
  &lt;li&gt;用户投放频次：Delivery capping per visitor: 此处可以设置总共以及每用户显示的限额次数。&lt;/li&gt;
  &lt;li&gt;其他：Miscellaneous: 如果希望隐藏与此广告计划关联的广告主和网站，可以进行设置。另外，也可以设置竞争机制，如果设置了竞争机制，则OpenX在显示的时候投放该计划下所有的广告。   &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;设置完成后，点击保存。&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;添加广告&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;点击添加广告（Add new banner）链接。&lt;/li&gt;
  &lt;li&gt;选择广告的类型（Please choose the type of the banner）。默认为上传本地广告物料文件到Web服务器（Upload a local banner to the webserver）。&lt;/li&gt;
  &lt;li&gt;填写广告名字（如广告 980 X 90）&lt;/li&gt;
  &lt;li&gt;上传图片&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-10&quot;&gt;广告类型&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;使用Web服务器的本地广告&lt;/strong&gt; 这是使用最广泛的广告类型。它用于图像广告包括JPG，GIF和PNG文件。广告上传到OpenX的广告服务器并存储在文件系统中的一个文件夹。安装系统时，默认图片文件上传到www/images/，并生生一个随机字符串文件名的文件。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;使用SQL的本地广告&lt;/strong&gt; 是把广告图保存在，在数据库中的二进制数据，而不是存储在一个文件夹。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;通用的HTML广告&lt;/strong&gt; 这可能是一个HTML网页的形式，多张图片，表格，JavaScript文件。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;通用文本横幅&lt;/strong&gt; 适用于任何拟作为纯文本显示。简单的文本链接是受欢迎的用法。此外，也可以写长段的文本作为广告。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;外部广告（即url图片地址）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-11&quot;&gt;添加网站&lt;/h3&gt;

&lt;p&gt;进入Inventory &amp;gt; Websites，在网站管理界面，在右上方选择添加新网站（Add new website），您将可以看到添加新网站界面。&lt;/p&gt;

&lt;p&gt;创建新网站：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网站URL（Website URL）: 输入您网站的URL。&lt;/li&gt;
  &lt;li&gt;网站名（Name）：输入网站名称。此名称将会显示在网站列表界面，注意网站名必须唯一。&lt;/li&gt;
  &lt;li&gt;联系人（Contact）：输入网站联系人。&lt;/li&gt;
  &lt;li&gt;Email: 输入网站管理员的Email地址。&lt;/li&gt;
  &lt;li&gt;类目（Category）：在下拉列表里选择网站的类目。&lt;/li&gt;
  &lt;li&gt;国家/语言（Country/Language）： 在下拉列表中选择相关的国家和语言。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完成以上操作后点击保存，添加网站成功。&lt;/p&gt;

&lt;h3 id=&quot;section-12&quot;&gt;添加广告位&lt;/h3&gt;

&lt;p&gt;进入Inventory &amp;gt; Zones，点击添加新广告位（Add new zone）选项，到达添加新广告位页面。&lt;/p&gt;

&lt;p&gt;添加新广告位：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;名称（Name）： 广告位名称必须唯一。如果此项为空，OpenX默认会设置一个名称，默认的是网站名称后面加上“-default”。&lt;/li&gt;
  &lt;li&gt;描述（Description）：输入广告位的相关信息。如广告位 980 X 90&lt;/li&gt;
  &lt;li&gt;行业分类（Category）：&lt;/li&gt;
  &lt;li&gt;类型（Zone type）：选择广告位类型（本指南有专门的页面解释各种广告位类型）&lt;/li&gt;
  &lt;li&gt;尺寸（Size）：必须为每个广告位选择尺寸（除了文字广告位之外），只有符合尺寸的广告创意才会在此广告位显示。下拉列表里面的尺寸都是IAB定义的标准尺寸，也可以设置自定义的尺寸。&lt;/li&gt;
  &lt;li&gt;备注（Comments）：广告位备注&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一旦完成操作点击保存，完成添加广告位。&lt;/p&gt;

&lt;h4 id=&quot;section-13&quot;&gt;广告位类型&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;旗帜，按钮，或矩形：&lt;/strong&gt;这是使用最广泛的广告位类型，可以显示包括图像在内的任何有创意的类型 JAVASCRIPT，HTML，等等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;浮动广告&lt;/strong&gt; 此广告位类型是用来显示浮动或弹出的横幅上，如出现网络浏览器的动态行为  消失了一段时间后，移动光标，等等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;文字广告&lt;/strong&gt; 你想要您的网站上卖文本连接，你应该使用这种类型&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;电子邮件/邮件列表版位&lt;/strong&gt; 如果你想给你的网站用户发送电子邮件和简讯，使用此广告位，可以在电子邮件中嵌入广告横幅。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-14&quot;&gt;链接广告到广告位&lt;/h3&gt;

&lt;p&gt;在广告位列表中，点击链接广告（Linked Banners），选择一个广告主和广告活动。&lt;/p&gt;

&lt;p&gt;或者在广告的详细页面的链接广告位（Linked Zones）标签中，选择一个广告位。&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;复制代码到网站&lt;/h3&gt;

&lt;p&gt;在广告位列表中，点击获取代码（Invocation Code）&lt;/p&gt;

&lt;h2 id=&quot;openx-&quot;&gt;Openx 账户类型&lt;/h2&gt;

&lt;p&gt;用户有一个用户名和密码，与至少一个OpenX帐户，并可以与任意数量的账户挂钩。一个用户可以有不同的连结多种帐户的多个角色。每个角色都有其自己的设置权限，定义用户可以执行相关联的帐户上的行动。&lt;/p&gt;

&lt;h3 id=&quot;section-16&quot;&gt;角色和权限&lt;/h3&gt;

&lt;p&gt;系统安装后的初始用户即是管理员，又是经理。&lt;/p&gt;

&lt;p&gt;进入广告主，或网站的详情编辑页面，点击用户访问（User Access）标签，在操作（Actions）下拉菜单中，可以创建或关联使用该账户访问的用户。&lt;/p&gt;

&lt;h4 id=&quot;administrator&quot;&gt;管理员（Administrator）&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;创建经理帐户&lt;/li&gt;
  &lt;li&gt;将用户添加到经理帐户&lt;/li&gt;
  &lt;li&gt;可以作为一个经理&lt;/li&gt;
  &lt;li&gt;创建其他管理员用户&lt;/li&gt;
  &lt;li&gt;查看主页和用户日志页&lt;/li&gt;
  &lt;li&gt;管理全球和维护设置&lt;/li&gt;
  &lt;li&gt;直接选择&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;manager&quot;&gt;经理（Manager）&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;创建和管理广告商和网站&lt;/li&gt;
  &lt;li&gt;添加其他的经理帐户&lt;/li&gt;
  &lt;li&gt;将用户添加到广告商和网站&lt;/li&gt;
  &lt;li&gt;查看主页和用户日志页&lt;/li&gt;
  &lt;li&gt;管理帐户偏好&lt;/li&gt;
  &lt;li&gt;渠道管理&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;website&quot;&gt;网站（Website）&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;创建区域&lt;/li&gt;
  &lt;li&gt;横幅链接到区域&lt;/li&gt;
  &lt;li&gt;生成调用代码&lt;/li&gt;
  &lt;li&gt;链接此帐户的其他用户&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;advertiser&quot;&gt;广告主（Advertiser）&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;查看广告活动&lt;/li&gt;
  &lt;li&gt;修改广告信息&lt;/li&gt;
  &lt;li&gt;激活广告活动&lt;/li&gt;
  &lt;li&gt;停用广告活动&lt;/li&gt;
  &lt;li&gt;链接此帐户的其他用户&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-17&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://openx.com/&quot;&gt;OpenX官网(http://openx.com/)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.openxconsultant.com/blog/2013/08/openx-source-v2-8-11-released-for-download/&quot;&gt;OpenX Source v2.8.11 released for download&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://download.openx.org/&quot;&gt;OpenX源代码历史版本(http://download.openx.org/)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://wenku.baidu.com/link?url=Cy8j6kSPXU6VRkc0umh5cSOfLh6ADzps41cddZZYPFVGylsVY2YBcBqwQw53azBG7duxkm15JxqQttraU0_8y-3S3yZae7y8b1VI3CsDKAm&quot;&gt;Openx 用户指南&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 16 Apr 2014 00:00:00 +0800</pubDate>
        <link>http://www.peigong.net/articles/studio/openx.html</link>
        <guid isPermaLink="true">http://www.peigong.net/articles/studio/openx.html</guid>
        
        <category>广告系统</category>
        
        
        <category>studio</category>
        
      </item>
    
      <item>
        <title>测试技能列表</title>
        <description>
&lt;h2 id=&quot;soft-skills&quot;&gt;Soft skills&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;测试用例设计能力：&lt;/strong&gt;将产品需求转化为测试用例，能够尽可能的保证考虑到各个方面，不会有遗漏。设计的用例标准，规范。可以反映清晰的思路。可以被重复执行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;测试计划能力：&lt;/strong&gt;可以对一个测试项目制定测试计划：包括风险，schedule，scope，strategy，resource等。计划合理，可以执行，并且有指导意义。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;测试项目管理能力：&lt;/strong&gt;能够作为project lead管理一个测试项目，合理分配资源，预见风险，处理问题，沟通协作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;测试团队lead能力：&lt;/strong&gt;能够负责一个测试团队，包括招聘，带领完成任务，performance review，处理各种问题等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Trouble Shooting 能力：&lt;/strong&gt;遇到出现的问题，可以找到问题所在。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;业务熟悉能力：&lt;/strong&gt;对于自己所负责的业务模块，熟悉其所有的逻辑，配置，部署，上下游关系。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;广告领域知识：&lt;/strong&gt;熟悉广告领域名词，逻辑关系，功能等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;召开并hold会议的能力：&lt;/strong&gt;可以就某一个问题，某一件事情，组织相关人员，召开会议，并且可以掌控会议。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;做好事情的能力：&lt;/strong&gt;善始善终，有责任感，对自己所做的事情负责。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;沟通协作能力：&lt;/strong&gt;说起来容易，做起来很难。To  be a good team player。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;tech-skills&quot;&gt;Tech skills&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Linux：&lt;/strong&gt;熟练掌握常用的各种命令，操作。掌握应用的安装，部署。熟悉如何查看进程，如何查看内存，查找文件等。知道如何查看log。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MySQL：&lt;/strong&gt;熟练掌握常用的SQL命令，熟练掌握通过客户端或者命令行去连接，查询。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Coding：&lt;/strong&gt;会熟练使用一种编程语言。可以为了解决某个问题，写一个工具去解决。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Automation：&lt;/strong&gt;熟练掌握一种自动化框架（如selenium），可以用它完成一种类型的自动化测试。自己可以积累一个框架，在以后做的项目中可以直接在该框架上去使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Redis:&lt;/strong&gt;掌握redis的安装，掌握常用的命令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Hadoop：&lt;/strong&gt;理解HDFS，理解Map/Reduce，可以自己独立搭建，并写出WordCount。理解公司所使用的job。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Zookeeper：&lt;/strong&gt;理解Zookeeper的特点，理解如何进行管理配置和管理集群。理解广告平台是如何利用zookeeper部署的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MongoDB：&lt;/strong&gt;理解MongoDB这种no-sql类型的数据库。知道如何用客户端连接。可以自己搭建单机，或者集群。可以进行读写导出的操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LVS:&lt;/strong&gt;理解公司如何用LVS做负载均衡。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Loadrunner：&lt;/strong&gt;可以使用loadrunner进行web性能测试，可以观测server端的性能指标。可以发送其他类型的请求。掌握性能分析的基本技能。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 15 Mar 2014 00:00:00 +0800</pubDate>
        <link>http://www.peigong.net/articles/lessons/test-skills.html</link>
        <guid isPermaLink="true">http://www.peigong.net/articles/lessons/test-skills.html</guid>
        
        <category>测试技能</category>
        
        
        <category>lessons</category>
        
      </item>
    
      <item>
        <title>Grunt入门指引</title>
        <description>
&lt;blockquote&gt;
  &lt;p&gt;熟练应用grunt工具，可为以后的开发做基础准备，节省人力；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;nodejsgrunt&quot;&gt;需要的工具及环境（node.js+grunt+插件库）&lt;/h2&gt;

&lt;p&gt;node.js、grunt、grunt插件库三者之间的关系如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;node.js有一个npm的命令包，所以只有正确安装node.js后才可以执行npm命令；&lt;/li&gt;
  &lt;li&gt;而grunt是运行在node.js环境下的一个工具，因此必须先安装node.js;&lt;/li&gt;
  &lt;li&gt;grunt构建工具中的less插件是grunt工具中众多插件中的一个插件，一定在grunt安装后，在此基础上安装less插件即
可在命令窗口中执行lessc命令（例如命令行：lessc nav/page.less&amp;gt;nav/page.css）;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;grunt的插件库：&lt;a href=&quot;https://github.com/gruntjs&quot;&gt;https://github.com/gruntjs&lt;/a&gt;这里面有n多个grunt的插件，可以选自己需要的来用&lt;/p&gt;

&lt;p&gt;综上所述：node.js、grunt、lessc是相互依存的关系；&lt;/p&gt;

&lt;h2 id=&quot;grunt&quot;&gt;grunt安装流程及配置&lt;/h2&gt;

&lt;p&gt;第一次制作时步骤如下：&lt;/p&gt;

&lt;p&gt;在安装grunt之前需要先安装node.js;&lt;/p&gt;

&lt;p&gt;2.1、安装node.js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;下载地址：http://nodejs.org/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时命令行中输入npm回车；如出现npm不是可执行命令提示，说明你未成功安装node.js&lt;/p&gt;

&lt;p&gt;解决方法：1）卸载node，重新安装；
2）检查环境变量，找到带有npm的环境变量，在其后添加：node.js字样；重启机器;&lt;/p&gt;

&lt;p&gt;2.2、安装grunt工具步骤：&lt;/p&gt;

&lt;p&gt;1）首先安装Grunt的命令行接口&lt;/p&gt;

&lt;p&gt;在命令窗口输入如下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g grunt-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）安装grunt-init（一个用于自动创建项目的脚手架工具）&lt;/p&gt;

&lt;p&gt;在命令窗口输入如下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g grunt-init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，会把grunt-init命令植入到你的系统路径，从而允许你在任何目录中都可以运行它。&lt;/p&gt;

&lt;p&gt;3）安装和使用gruntfile模板&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/clientlab/grunt-init-gruntfile.git ./gruntfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.1）下载下来的模板名为grunt-init-gruntfile-master.zip；首先解压文件并更名为：&lt;strong&gt;gruntfile&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;目录如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gruntfile/
gruntfile/README.md
gruntfile/template.js
gruntfile/root/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.2）打开你的“C:\Users\你的用户名”这个目录（例如C:\Users\用户名）， &lt;code&gt;shift+右键&lt;/code&gt;打开命令窗口，执行如下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	mkdir .grunt-init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是会出现一个“.grunt-init”文件夹；&lt;/p&gt;

&lt;p&gt;3.3）把模板拷贝到”grunt-init“文件夹下；&lt;/p&gt;

&lt;p&gt;3.4）在与你项目外（例如abc项目外）,按Shift+鼠标右键，打开右键菜单，选择“在此处打开命令窗口(W)”，打开命令行，执行如下程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt-init gruntfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果执行正确，命令窗口中会出现一些提示文字（这相当于grunt插件选择，如果提到你需要的插件,回答Y即可，下面是以”web开发“需要的插件选择为例）：&lt;/p&gt;

&lt;p&gt;1、Grunt项目的名称：（这里我们开发的是abc项目即输入abc即可） abc&lt;/p&gt;

&lt;p&gt;2、Grunt项目的详细描述：（可以简单写一些描述，最好用英文）the website plug-in library&lt;/p&gt;

&lt;p&gt;3、是否需要创建一个 package.json 文件？ Y&lt;/p&gt;

&lt;p&gt;4、是否需要使用清理文件的任务？Y&lt;/p&gt;

&lt;p&gt;5、是否需要使用文件复制的任务？ Y&lt;/p&gt;

&lt;p&gt;6、是否需要使用查找替换点位符的过滤器任务？ N&lt;/p&gt;

&lt;p&gt;7、是否需要使用合并文件的任务？ Y&lt;/p&gt;

&lt;p&gt;8、是否需要使用生成JSDoc的任务？N&lt;/p&gt;

&lt;p&gt;9、是否需要使用代码压缩的任务？ N&lt;/p&gt;

&lt;p&gt;10、是否需要使用javascript语法检查的任务？ Y&lt;/p&gt;

&lt;p&gt;11、是否需要使用QUnit的单元测试任务？N&lt;/p&gt;

&lt;p&gt;12、是否需要使用Less任务？ Y&lt;/p&gt;

&lt;p&gt;13、是否需要使用CSS语法检查任务？Y&lt;/p&gt;

&lt;p&gt;回车，再看项目文件夹中会出现两个文件，Gruntfile.js和package.json&lt;/p&gt;

&lt;p&gt;以上的工作完成，你已经拥有了一个我们要用到的的grunt的全部；&lt;/p&gt;

&lt;h2 id=&quot;gruntfilejspackagejson&quot;&gt;开始配置:Gruntfile.js和package.json&lt;/h2&gt;

&lt;h3 id=&quot;gruntfilejs&quot;&gt;1、Gruntfile.js&lt;/h3&gt;

&lt;p&gt;打开Gruntfile.js文件，按如下设置修改；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function(grunt) {

grunt.initConfig({
pkg: grunt.file.readJSON(&#39;package.json&#39;),
clean: {//清除插件的配置
  dist: [&#39;dist/path&#39;]
}, 
less: {//less插件的配置
  development:{
options: {
  rootpath:&#39;&#39;,
  paths: [&quot;src&quot;],
  cleancss:true,
  ieCompat:true,
  strictUnits:true,//验证所使用的单位
},
files: {
  &quot;path/css/base.css&quot;: &quot;path/less/base.less&quot;,
  &quot;path/css/abc.css&quot;: &quot;path/less/abc.less&quot;
}
  },
},
  jshint: {
  all: [&#39;path/abc.js&#39;]
},
  copy: {//复制插件的配置
dist: {
  files: [ 
{
  expand: true,
  cwd: &#39;src&#39;,
  src:[&#39;path/**&#39;],
  dest:&#39;dist/&#39;
}
  ]
}
  },
 
  });
  grunt.loadNpmTasks(&#39;grunt-contrib-clean&#39;);//清除插件
  grunt.loadNpmTasks(&#39;grunt-contrib-less&#39;);//less转换为css的插件
  grunt.loadNpmTasks(&#39;grunt-contrib-jshint&#39;);//检查js语法检查插件
  grunt.loadNpmTasks(&#39;grunt-contrib-copy&#39;);//复制插件
 

  // Default task.
  grunt.registerTask(&#39;default&#39;, [&#39;clean&#39;,&#39;less&#39;,&#39;jshint&#39;,&#39;copy&#39;]);//任务请求顺序列表；插件名称排列的位置决定着执行顺序；

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ps:一般我们会建一个src文件夹（用来存放源文件，即我们日常维护的文件包），grunt会给我们构建出一个dist文件夹（用来分发到各个项目中的文件；）&lt;/p&gt;

&lt;p&gt;以上是基础设置，在以后使用时可以根据需求自己修改；&lt;/p&gt;

&lt;h3 id=&quot;packagejsongruntfile&quot;&gt;2、package.json（一组和Gruntfile相对应的插件信息）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;name&quot;: &quot;plug-in&quot;,
  &quot;description&quot;: &quot;the website plug-in library&quot;,
  &quot;devDependencies&quot;: {
    &quot;grunt&quot;: &quot;~0.4.1&quot;,
    &quot;grunt-contrib-clean&quot;: &quot;~0.4.0&quot;,//清除插件及版本号
    &quot;grunt-contrib-copy&quot;: &quot;~0.4.0&quot;,//复制插件及版本号
    &quot;grunt-contrib-less&quot;: &quot;^0.10.0&quot;,//less插件及版本号
    &quot;grunt-contrib-jshint&quot;: &quot;^0.8.0&quot;//js语法检查插件及版本号
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上两个文件的配置会根据需求的不同而不同，我们一般用到的插件是clean、copy、less等；&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;配置结束后，需要根据配置文件安装插件&lt;/h2&gt;

&lt;p&gt;执行命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后可以看到文件中生成了一个”node_modules“，因为文件较大一般会在项目文件外执行；&lt;/p&gt;

&lt;p&gt;这个命令只需要在最初安装时执行一次（这相当于你安装了一个软件，只需安装一次，以后就可以直接拿来用了），以后可以直接用grunt命令构建项目即可&lt;/p&gt;

&lt;p&gt;在以后的工作中会频繁的用到如下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，一个完整的grunt构建配置就完成了~so easy吧~&lt;/p&gt;
</description>
        <pubDate>Fri, 07 Mar 2014 00:00:00 +0800</pubDate>
        <link>http://www.peigong.net/articles/lessons/grunt-getting-started.html</link>
        <guid isPermaLink="true">http://www.peigong.net/articles/lessons/grunt-getting-started.html</guid>
        
        <category>开发工具</category>
        
        
        <category>lessons</category>
        
      </item>
    
      <item>
        <title>GitLab和TortoiseGit、msysGit的配合使用</title>
        <description>
&lt;h2 id=&quot;section&quot;&gt;软件安装&lt;/h2&gt;

&lt;p&gt;下载和安装windows下Git环境：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://code.google.com/p/tortoisegit/&quot;&gt;TortoiseGit(https://code.google.com/p/tortoisegit/)&lt;/a&gt;，是TortoiseSVN的Git变种，主要用于图形化显示。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://code.google.com/p/msysgit/&quot;&gt;msysGit(https://code.google.com/p/msysgit/)&lt;/a&gt;，windows下的Git版本，是TortoiseGit所必须依赖的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下载完两个软件之后，首先安装TortoiseGit，安装完TortoiseGit之后先别急着用，接着安装msysGit，安装过程中的一些选项都可以默认！&lt;/p&gt;

&lt;h2 id=&quot;sshgit-bash&quot;&gt;SSH密钥和Git Bash&lt;/h2&gt;

&lt;p&gt;本节介绍在Git命令行（Git Bash）中SSH密钥的生成，以及在Gitlab上的使用。&lt;/p&gt;

&lt;p&gt;使用命令行进行Git操作，显得高端、大气、上档次。如果你不慕虚名，只想生活简单而美好，就像使用SVN小乌龟（TortoiseSVN）那样工作，可以直接跳过本节。&lt;/p&gt;

&lt;h3 id=&quot;ssh&quot;&gt;生成SSH密钥&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;检查当前用户目录中有没有.ssh目录。如果没有的话，在命令行中使用&lt;code&gt;mkdir .ssh&lt;/code&gt;创建。&lt;/li&gt;
  &lt;li&gt;安装Git后，进入某个目录，使用右键菜单打开 “Git Bash”。&lt;/li&gt;
  &lt;li&gt;键入命令：&lt;code&gt;ssh-keygen -t rsa -C &quot;your email&quot;&lt;/code&gt;。邮件地址可以不写，默认是&lt;code&gt;本机用户名@本机机器名&lt;/code&gt;。最好是填写一些标识自己的记号。&lt;/li&gt;
  &lt;li&gt;提醒你输入key的名称，输入“id_rsa”。&lt;strong&gt;注意：&lt;/strong&gt;id_rsa名字是固定的，因为GitLab只认识这个。&lt;/li&gt;
  &lt;li&gt;提醒你输入key的密码，空白即可。&lt;/li&gt;
  &lt;li&gt;在当前目录下产生两个密钥文件：id_rsa和id_rsa.pub&lt;/li&gt;
  &lt;li&gt;把生成的密钥文件复制到当前用户的.ssh目录下。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;gitlab&quot;&gt;在Gitlab上添加公钥&lt;/h3&gt;

&lt;p&gt;用记事本打开、复制id_rsa.pub文件的内容，在Gitlab网站My Porfile页面右下角，点击“Add Public Key”，粘贴刚才复制的内容到Key的大文本框，提交即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在复制内容的时候，文本的两端都不要有空格和换行。&lt;/p&gt;

&lt;h3 id=&quot;git&quot;&gt;在命令行中进行Git操作&lt;/h3&gt;

&lt;p&gt;从程序目录打开 “Git Bash”（或使用右键菜单），在命令行中&lt;code&gt;git clone&lt;/code&gt;一个项目。&lt;/p&gt;

&lt;p&gt;提示是否把项目Git库的域名设置为可信任的已知域名，直接回答&lt;code&gt;yes&lt;/code&gt;就可以了。&lt;/p&gt;

&lt;p&gt;其他命令，一样的用法。不清楚的话，可以查阅《&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot;&gt;史上最浅显易懂的Git教程&lt;/a&gt;》。&lt;/p&gt;

&lt;h2 id=&quot;tortoisegit&quot;&gt;TortoiseGit中的密钥&lt;/h2&gt;

&lt;p&gt;本节介绍在Git小乌龟（TortoiseGit）中生成密钥，以及在Gitlab上的使用。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;生成密钥&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;在开始菜单-&amp;gt;TortoiseGit-&amp;gt;Puttygen。这是一个用于TortoiseGit的Putty密钥生成器。&lt;/li&gt;
  &lt;li&gt;点击“generate”按钮。让鼠标在“generate”按钮以上、进度条以下的空白区域随机晃动，直到密钥生成完毕。&lt;/li&gt;
  &lt;li&gt;复制粘贴空白区域生成的SSH密钥文本（ssh-rsa。。。），在Gitlab网站My Porfile页面右下角，点击“Add Public Key”，粘贴刚才复制的内容到Key的大文本框，提交即可。&lt;strong&gt;注意：&lt;/strong&gt;在复制内容的时候，文本的两端都不要有空格和换行。Title文本框随便写一些内容就可以，主要是区别不同的Key，没有特别的用途。&lt;/li&gt;
  &lt;li&gt;点击“save private key”按钮，把文件生成在当前用户目录下的.ssh目录中（生成的文件后缀是&lt;code&gt;.ppk&lt;/code&gt;）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;使用右键菜单&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;在打算&lt;code&gt;git clone&lt;/code&gt;项目的目录中，右键选择&lt;code&gt;Git克隆&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;勾选“加载putty密钥”，并选择上面生成的后缀是&lt;code&gt;.ppk&lt;/code&gt;的私钥文件。&lt;/li&gt;
  &lt;li&gt;后续的操作，及除&lt;code&gt;git clone&lt;/code&gt;以外的工作，就不需赘述了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot;&gt;史上最浅显易懂的Git教程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://git-scm.com/book/zh&quot;&gt;The entire Pro Git book&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://feiyang.me/2013/03/work-with-gitlab/&quot;&gt;用Gitlab来工作&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.docin.com/p-596784591.html&quot;&gt;GitLab使用介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/bluesky8640/article/details/8171104&quot;&gt;GitLab在windows用户端的使用教程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/lenolix/archive/2013/02/06/2906466.html&quot;&gt;gitlab搭建之旅&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.linuxidc.com/Linux/2013-05/85184.htm&quot;&gt;在CentOS里安装GitLab&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://herry2013git.blog.163.com/blog/static/219568011201341111240751/&quot;&gt;gitlab多人协同工作&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aur.archlinux.org/packages/gitlab/?setlang=zh_CN&quot;&gt;软件包详情: gitlab 6.4.0-1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 22 Feb 2014 00:00:00 +0800</pubDate>
        <link>http://www.peigong.net/articles/lessons/TortoiseGit-andl-msysGit-for-gitlab.html</link>
        <guid isPermaLink="true">http://www.peigong.net/articles/lessons/TortoiseGit-andl-msysGit-for-gitlab.html</guid>
        
        <category>开发工具</category>
        
        
        <category>lessons</category>
        
      </item>
    
      <item>
        <title>Yeoman的安装和使用</title>
        <description>
&lt;h2 id=&quot;section&quot;&gt;安装步骤&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;本教程的内容较少原创，多从其他文档上摘录。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yeoman 1.0 包含以下三套工具，分別說明如下：&lt;/p&gt;

&lt;p&gt;yo - the scaffolding tool from Yeoman ( 用來自動產生網站骨架或程式碼的工具 )
bower - the package management tool ( 用來管理特定網站下所使用的各式前端套件，如: jQuery )
grunt - the build tool ( 用來執行一些網站的自動化工作，例如單元測試、最小化、執行批次命令 )
要安裝這三套工具之前，還有許多相依的工具必須事先安裝，否則工具指令會無法正確執行，以下包括 node.js , Git for Windows 與 RubyInstaller 這三套工具的安裝注意事項：&lt;/p&gt;

&lt;h4 id=&quot;nodejs-for-windows&quot;&gt;安裝 node.js for Windows&lt;/h4&gt;

&lt;p&gt;请选择正確的 Windows 安裝包，注意 CPU 架構有区分 32-bit 与 64-bit 两种：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://clientlab.github.io/images/articles/lessons/install-yeoman/node.png&quot; alt=&quot;node安装包&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安裝时要确保 Add to PATH 項目有被安装进去：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://clientlab.github.io/images/articles/lessons/install-yeoman/node2.png&quot; alt=&quot;node安装&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;git-for-windows-&quot;&gt;安裝 Git for Windows 工具&lt;/h4&gt;

&lt;p&gt;安裝到 Adjusting your PATH environment 步骤時，选择 Run Git from the Windows Command Prompt 的相容性比较高，问题也会少很多：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://clientlab.github.io/images/articles/lessons/install-yeoman/git.png&quot; alt=&quot;git安装&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其他保留预设值即可。&lt;/p&gt;

&lt;h4 id=&quot;ruby-&quot;&gt;安装 Ruby 执行环境&lt;/h4&gt;
&lt;p&gt;由於前端开发作业经常会用到 Compass 工具撰写 CSS，而且在使用 Yeoman 的時候，有些产生器所产生的 grunt 定义包也会用到 Compass 来执行，所以可以预先安装好。&lt;/p&gt;

&lt;p&gt;安裝 Compass 工具会需要先安裝 Ruby 才能安装与使用。建议通过 RubyInstaller (Windows) 提供的 MSI 安装包进行安裝，但安裝的过程中有一個步驟非常重要，你必須在 Installation Destination and Optional Tasks 步驟時，勾选 Add Ruby executables to your PATH 选项才行，如下图示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://clientlab.github.io/images/articles/lessons/install-yeoman/ruby.png&quot; alt=&quot;ruby安装&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安裝好这些工具之后，就可以开始准备安裝 Yeoman 相关工具了：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;打开命令行。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用npm 安裝 yo , bower 與 grunt 工具。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; npm install -g yo grunt-cli bower
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;其中 -g 代表要把 yo , grunt-cli , bower 這三个套件安裝到全域 (global)&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://clientlab.github.io/images/articles/lessons/install-yeoman/yo.png&quot; alt=&quot;yo安装&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安裝 yo 相关的 程序码产生器 (generator) 套件&lt;/p&gt;

    &lt;p&gt;因為 yo 這套工具主要就是用來自動產生網站骨架或程式碼，在執行 yo 之前，你必須預先安裝好這些程式碼產生器範本，這些被稱為 YEOMAN GENERATORS，你可以在 YEOMAN GENERATORS 找到許多現成的產生器範本，並且一樣透過 npm 進行安裝。&lt;/p&gt;

    &lt;p&gt;例如你在 YEOMAN GENERATORS 頁面找到一個 webapp 產生器，那麼你可以用以下指令進行安裝：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; npm install -g generator-webapp  如果想安裝 angular 產生器，那麼你可以用以下指令進行安裝：

 npm install -g generator-angular  以此類推！
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你要順道安裝 Compass 的話，也可以輸入以下指令進行安裝&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; gem update --system
 gem install compass
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;Yeoman 與 Compass 安裝完成！&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;yeoman-&quot;&gt;Yeoman 的使用&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;先创建一个网站目录，例如webapp。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在这个目录下，命令行执行命令，产生网站骨架：
 yo angular&lt;/p&gt;

    &lt;p&gt;这是一個交互的过程，yo安装哪些模块：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://clientlab.github.io/images/articles/lessons/install-yeoman/create.png&quot; alt=&quot;创建网站&quot; /&gt;
 安装完成后可能会遇到一些问题，如：
 &lt;img src=&quot;http://clientlab.github.io/images/articles/lessons/install-yeoman/create2.png&quot; alt=&quot;创建网站&quot; /&gt;
 表示依赖的模块需要手动bower install &amp;amp; npm install安装。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 23 Jan 2014 00:00:00 +0800</pubDate>
        <link>http://www.peigong.net/articles/lessons/installation-and-use-of-yeoman.html</link>
        <guid isPermaLink="true">http://www.peigong.net/articles/lessons/installation-and-use-of-yeoman.html</guid>
        
        <category>开发工具</category>
        
        <category>Yeoman</category>
        
        <category>脚手架</category>
        
        
        <category>lessons</category>
        
      </item>
    
      <item>
        <title>语义化版本控制 2.0.0</title>
        <description>
&lt;blockquote&gt;
  &lt;p&gt;译者注1：Semantic Versioning 2.0.0的原文地址是&lt;a href=&quot;http://semver.org&quot;&gt;http://semver.org&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;概要&lt;/h2&gt;

&lt;p&gt;版本号MAJOR.MINOR.PATCH（主版本号.副版本号.补丁版本号）的递增规则如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当以不向后兼容的方式，变更API时，递增主版本号。&lt;/li&gt;
  &lt;li&gt;当以向后兼容的方式，增加功能时，递增副版本号。&lt;/li&gt;
  &lt;li&gt;当以向后兼容的方式，修正BUG时，递增补丁版本号。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;预发布信息和构建元数据可以作为附加标签，扩展MAJOR.MINOR.PATCH（主版本号.副版本号.补丁版本号）的格式。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;引言&lt;/h2&gt;

&lt;p&gt;在软件开发管理的世界里，有一个可怕的地方叫做“依赖关系地狱”。当你的系统越来越大，集成了更多的包，你就会深刻的认识到自己的卑微和渺小。直到有一天，你在这个坑里彻底绝望。&lt;/p&gt;

&lt;p&gt;系统依赖的模块发布新版本，就成了噩梦。如果依赖关系的规定过于严格，会遇到一个版本依赖关系的死结（升级一个依赖包之前，必须升级完所有的依赖包）。如果依赖关系规定的太松散，版本依赖关系的混乱就会成为你的切肤之痛（假定你的版本兼容性很重要）。当版本依赖关系的死结、混乱，让你不能轻松、安全的向前迁移项目的时，你就坠入了“依赖关系地狱”。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，我提出了一套简单的规则和要求，决定版本号如何分配和递增。这些规则都是基于（但不限于）业界早已存在的流行做法。使用此制度的软件必须声明一个公共API，可以在代码内部声明，也可以严格地写入文档中，但必须是清晰而准确的。一旦确定了公共API，都必须通过明确的版本号递增，来表明系统所做的变更。认真考虑一下X.Y.Z（主版本号.副版本号.补丁版本号）的版本格式。不影响API的BUG修正,递增补丁版本号。向后兼容API的功能新增或变更，递增副版本号。不向后兼容的API变更，递增主版本号。&lt;/p&gt;

&lt;p&gt;我把这个制度称为“语义化版本控制”。在这个方案中，规范了从一个版本到下一个版本的版本号，规范了更改版本号传达源代码意图的方法，以及源代码做了什么样的修改。&lt;/p&gt;

&lt;h2 id=&quot;semver&quot;&gt;语义化版本控制规范（SemVer）&lt;/h2&gt;

&lt;p&gt;在本文档中，对关键词（”MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL”）的使用，遵循&lt;a href=&quot;http://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119标准&lt;/a&gt;的规范。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;译者注2：RFC2119标准规范了表示“要求”（Requirement）的动词涵义。关于RFC2119标准可以参考《&lt;a href=&quot;http://blog.csdn.net/bryangg/article/details/2443488&quot;&gt;RFC2119 中文版-RFC文档用于指出要求级别的关键字&lt;/a&gt;》。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;使用语义化版本控制的软件必须（MUST）声明一个公共的API。这个API可以在源代码的内部声明，也可以在文档中严格的定义。无论怎么做，都应该是清晰而全面的。&lt;/li&gt;
  &lt;li&gt;一个标准的版本号必须（MUST）是X.Y.Z的形式。其中的X、Y和Z都要是正整数，并且禁止（MUST NOT）包含前导零。X是主版本号，Y是副版本号，Z是补丁版本号。每个元素数字的递增，必须（MUST）是1。例如：&lt;code&gt;1.9.0 -&amp;gt; 1.10.0 -&amp;gt; 1.110&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;一旦发布一个包的版本，该版本的内容禁止（MUST NOT）再做任何修改。任何的修改都必须（MUST）发布一个新的版本。&lt;/li&gt;
  &lt;li&gt;主版本0（0.y.z）用于初始开发。此时的公共API随时都可能会改动，是不稳定的。&lt;/li&gt;
  &lt;li&gt;在1.0.0版本中，公共API作出正式的定义。后续的版本号变更，都决定于公共API是否变更，以及如何变更。&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;以向后兼容的方式修正BUG时，必须（MUST）递增补丁版本号Z(x.y.Z&lt;/td&gt;
          &lt;td&gt;x &amp;gt; 0)。BUG修正的定义，是在源代码内部修正错误的行为。&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;当以向后兼容的方式变更公共API时，或者公共API中原有的功能标记为“不建议使用（deprecated）”时，必须（MUST）递增副版本号Y(x.Y.z&lt;/td&gt;
          &lt;td&gt;x &amp;gt; 0 )。源代码内部大量增加、修改功能时，也可以（MAY）递增副版本号。副版本号的递增可以（MAY）包括补丁版本的更新内容。副版本号递增后，补丁版本号必须（MUST）重置为0。&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;当以不向后兼容性的方式，变更公共API时，必须（MUST）递增主版本号X(X.y.z&lt;/td&gt;
          &lt;td&gt;X &amp;gt; 0)，可以（MAY）包含副版本和补丁版本级别的变更。主版本递增后，副版本号和补丁版本号必须（MUST）重置为0。&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;预发布的版本号，可以（MAY）在补丁版本号后面，添加一个破折号和一系列被点分割的标识符。这些标识符必须（MUST）由ASCII码中的字母和数字以及连字符[0-9A-Za-z-]组成。标识符禁止（MUST NOT）为空。数字禁止（MUST NOT）包含前导0。预发布版本号的优先级比正常的版本号低。预发布版本号表示该版本是不稳定的，可能无法达到其指明的正常版本号的兼容性预期。例如：&lt;code&gt;1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;构建的元数据，可以（MAY）在补丁版本号或预发布版本号后面，添加一个加号和一系列由连字符分隔的标示符组成。这些标识符必须（MUST）由ASCII码中的字母和数字以及连字符[0-9A-Za-z-]组成。标识符禁止（MUST NOT）为空。在确定版本号的优先级时，构建元数据应该（SHOULD）被忽略。因此，如果两个版本号的差异，仅仅在于构建元数据，就视为具有相同的优先级。例如：&lt;code&gt;1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;优先级是指在排序时，版本号之间如何进行比较。优先级必须（MUST）是，根据版本号按照主版本号、副版本号、补丁版本号和预发布标识的顺序进行计算产生的（构建元数据不参与优先级的比较）。优先级总是从左到右的，依次比较主版本号、副版本号、补丁版本号的数字大小。例如：&lt;code&gt;1.0.0 &amp;lt; 2.0.0 &amp;lt; 2.1.0 &amp;lt; 2.1.1&lt;/code&gt;。在主版本号、副版本号、补丁版本号都相同时，预发布版本号的优先级低于正常版本号。例如：&lt;code&gt;1.0.0-alpha &amp;lt; 1.0.0&lt;/code&gt;。两个预发布版本号的主版本号、副版本号、补丁版本号都相同时，优先级必须（MUST）从左至右的比较由点分隔的标识符，直到发现差异。标识符仅由数字组成的，比较数字的大小。标识符包含字母或连字符的，按照ASCII码的顺序进行比较。数字标识符总是小于非数字标识符。如果前面所有的标识符都是相同的，版本号中预发布字段较长的，优先级较高。例如：&lt;code&gt;1.0.0-alpha &amp;lt; 1.0.0-alpha.1 &amp;lt; 1.0.0-alpha.beta &amp;lt; 1.0.0-beta &amp;lt; 1.0.0-beta.2 &amp;lt; 1.0.0-beta.11 &amp;lt; 1.0.0-rc.1 &amp;lt; 1.0.0&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;为什么要使用语义化版本控制&lt;/h2&gt;

&lt;p&gt;语义化版本控制并不新鲜，也不是一个革命性的想法。事实上，你可能做了很多，已经完成了这件事。问题是完成并不等于极致。如果不符合某种正式的规范，版本号在依赖关系管理上基本没有什么用处。给上述想法起个名字，做出清晰的定义，就很容易向软件用户传达你的意图。一旦这些意图是明确的，一个灵活的（但也不能太灵活）依赖关系管理规范，就流畅的运转起来了。&lt;/p&gt;

&lt;p&gt;举一个简单的例子，说明语义化版本控制如何把你从“依赖关系地狱”中拯救出来。设想一个叫“消防车”的库，依赖一个使用语义化版本控制的包，名叫“梯子”。“消防车”刚刚生产出来的时候，梯子的版本号是3.1.0。由于“消防车”使用了在3.1.0版本才开始提供的一些功能，你就可以放心地指定依赖的“梯子”的版本大于等于3.1.0，但低于4.0.0。现在，当“梯子”有3.1.1和3.2.0的版本可用时，就可以更新到你的包管理系统，并知道他们将与当前依赖的软件兼容。&lt;/p&gt;

&lt;p&gt;作为一个负责任开发者，你当然会验证任何包所标榜的新功能。现实世界可是一个鱼龙混杂的地方，做什么事情都可以，但要警惕。你可以让语义化版本控制，给你提供一个稳健的方式来发布和升级包，不必再被迫为使用依赖包的新版本而反复折腾，为你节省时间，减少麻烦。&lt;/p&gt;

&lt;p&gt;如果这一切听起来还不错，你需要做的所有事情，就是开始声明你正在使用语义化版本控制，并遵循其规则。欢迎你在README文档中链接这个网站(译者注3)，让更多的人知道这个规则，并从中受益。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;译者注3：原文中提到的网站是指&lt;a href=&quot;http://semver.org&quot;&gt;http://semver.org&lt;/a&gt;。如果你愿意，也欢迎你加上本文的链接地址&lt;a href=&quot;http://clientlab.github.io/studio/2013/11/16/semantic-versioning-2.0.0/&quot;&gt;http://clientlab.github.io/studio/2013/11/16/semantic-versioning-2.0.0/&lt;/a&gt;，让更多使用中文的人知道这些规则，并从中受益。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-3&quot;&gt;常见问题&lt;/h2&gt;

&lt;h3 id=&quot;yz&quot;&gt;在0.y.z的初始开发阶段，我应该怎么处理我的修订？&lt;/h3&gt;

&lt;p&gt;最简单的做法就是从0.1.0版本开始你的初始开发，在后续的发布中递增副版本号。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;我怎么知道什么时候发布1.0.0版本？&lt;/h3&gt;

&lt;p&gt;如果你的软件在产品环境中使用，它可能已经应该是1.0.0。如果的软件用户，已经开始依赖一个稳定的API，应该是1.0.0。如果你担心很多向后兼容的问题，应该已经是1.0.0。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;这难道不会妨碍快速开发和快速迭代吗？&lt;/h3&gt;

&lt;p&gt;所有在快速开发和快速迭代的时候，主版本号都是0。如果你的API每天都在改变，仍然应该会在版本0.y.z阶段。或者，在一个单独的开发分支中，开展下一个主版本的开发工作。&lt;/p&gt;

&lt;h3 id=&quot;api4200&quot;&gt;公共API如果连最微小的向后不兼容的改变，都需要一个主版本号的冲击，会不会太迅速的就到了42.0.0版本？&lt;/h3&gt;

&lt;p&gt;这是一个负责任的开发问题，也是一个有远见的问题。在有大量依赖关系管理的软件中，不应该轻率的推出不兼容的改变。升级所必须付出的成本是有意义的。发布冲击主版本号的不兼容改变，意味着你深思熟虑过将要发生的震荡，有磕碰主要版本发布不兼容的改变意味着你想通过你的变化的影响，并评估过所涉及的投入产出比。&lt;/p&gt;

&lt;h3 id=&quot;api&quot;&gt;记录整个公共API是​太辛苦了！&lt;/h3&gt;

&lt;p&gt;为预计会给其他人使用的软件，提供适当的文档，是一个专业开发者的责任。控制软件的复杂性，是保持项目高效的一个非常重要的组成部分。如果没有谁知道如何使用你的软件，或者用什么方法可以安全地调用，保持项目高效是很难做到的。从长远来看，采用语义化版本控制，坚定的看守一个定义良好的公共API，可以让每一个人都能流畅的做每一件事。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;如果不小心，使用副版本号发布了一个不能向后兼容的变更，该怎么办啊？&lt;/h3&gt;

&lt;p&gt;一旦意识到已经破坏了语义化版本规范，要发布修正了问题，并且恢复向后兼容的新的主版本号。即便是这样，这也是一次不能接受的版本发布。如果方便，一定要记录有问题的版本，并通知你的用户，让他们意识到问题的存在。&lt;/p&gt;

&lt;h3 id=&quot;api-1&quot;&gt;如果更新了自己的依赖  但不改变公共API，版本号应该怎么规划？&lt;/h3&gt;

&lt;p&gt;这是向后兼容的，因为不影响公共API。如果软件与你的包有相同的依赖，有可能会有自己的依赖关系规范，而且软件的作者也会关切任何有可能的冲突。确定这个依赖变更是补丁级别的，还是副版本级别的，取决于你更新你的依赖是要修正一个BUG，还要要引入一组新的功能。我们通常期待是后者，哪怕增加大量的代码。因为在这种情况下，就显然是一个副版本级别的变更了。&lt;/p&gt;

&lt;h3 id=&quot;api-2&quot;&gt;如果在不经意间，以不符合版本规范的方式，改了变公共API怎么办（也就是，在一个补丁版本的发布中，源代码错误的引入了一个主版本级别的重大变更）？&lt;/h3&gt;

&lt;p&gt;那你就发挥出色的判断能力吧。如果拥有大量的忠实拥趸，愿意委曲求全的回到公共API的预期轨道上来，那你最好发布一个主版本。哪怕没什么修改，严格的说也只是补丁级别的。请记住，语义化版本控制是通过版本号的变更来传达意图的。如果变更对你的用户很重要，就使用版本号通知他们。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;我应该如何处理以后要废弃的功能？&lt;/h3&gt;

&lt;p&gt;废弃某些功能，在软件开发中很常见的，通常也会推动软件向前发展。&lt;/p&gt;

&lt;p&gt;在废弃公共API的一部分时，你要做两件事：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;更新你的文档，让用户知道这些变更。&lt;/li&gt;
  &lt;li&gt;发布包含废弃功能的副版本。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;你在主版本中彻底删除这些功能之前，至少要在发布的一个副版本中包含这些功能，好让用户平滑的迁移到新的API上来。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;在语义化版本控制中，版本号的长度有限制吗？&lt;/h3&gt;

&lt;p&gt;没有什么限制，但是你最好保持理智。比如，一个版本号有255个字符，就有点出格了。另外，在开发团队中具体的制度可能会有一些自定义的长度限制。&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;关于作者&lt;/h2&gt;

&lt;p&gt;语义化版本控制规范是由&lt;a href=&quot;http://tom.preston-werner.com/&quot;&gt;Tom Preston-Werner&lt;/a&gt;编写的。他是&lt;a href=&quot;http://en.gravatar.com/&quot;&gt;Gravatars&lt;/a&gt; 的创始人，也是&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;的共同创办人。&lt;/p&gt;

&lt;p&gt;如果你有一些反馈，可以在&lt;a href=&quot;https://github.com/mojombo/semver/issues&quot;&gt;GitHub上提交一个问题&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;许可证&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://creativecommons.org/licenses/by/3.0/&quot;&gt;知识共享 - CC 3.0&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.fallhunter.com/p/10555&quot;&gt;语义化版本号 Sematic Versioning(http://www.fallhunter.com/p/10555)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.neekey.me/blog/2012/02/27/semantic-versioning/&quot;&gt;Semantic Versioning 语义化版本号(http://blog.neekey.me/blog/2012/02/27/semantic-versioning/)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/bryangg/article/details/2443488&quot;&gt;RFC2119 中文版-RFC文档用于指出要求级别的关键字&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 16 Nov 2013 00:00:00 +0800</pubDate>
        <link>http://www.peigong.net/articles/studio/semantic-versioning-2.0.0.html</link>
        <guid isPermaLink="true">http://www.peigong.net/articles/studio/semantic-versioning-2.0.0.html</guid>
        
        <category>开发规范</category>
        
        
        <category>studio</category>
        
      </item>
    
      <item>
        <title>JSHint 使用说明（转）</title>
        <description>
&lt;blockquote&gt;
  &lt;p&gt;本文全文转自&lt;a href=&quot;http://zhang.zipeng.info/vimwiki/Entries/Reference/Tools/jshint.html&quot;&gt;JSHint 使用说明(http://zhang.zipeng.info/vimwiki/Entries/Reference/Tools/jshint.html)&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;jshint&quot;&gt;JSHint介绍&lt;/h2&gt;

&lt;p&gt;翻译自：www.jshint.com&lt;/p&gt;

&lt;p&gt;JSHint(注意不是jslint：）)是一个由javascript社区驱动开发的用于检查javascript代码错误和问题的工具，有了他，可以使你保持一个良好的编码风格。你可以很简单的配置它以适应你目前的一个编码风格。目前JSHint的源码可以在github上面找到。&lt;/p&gt;

&lt;h2 id=&quot;jshint-1&quot;&gt;JSHint文档&lt;/h2&gt;

&lt;h3 id=&quot;jshint-2&quot;&gt;如何使用JSHint&lt;/h3&gt;

&lt;p&gt;JSHint是一个全局的函数，他接受两个参数，JSHint(source,options); 一个是代码source，另一个是options（选项） 第一个参数可以是一个字符串或者是一个字符串数组。如果是字符串，则他会被\n和\r分割，如果传入的参数是数组，就要保证数组的每一项是一行代码。 因此源码参数可以是javascript代码或者是一个json形式。如果所有的检测都ok，JSHint会返回true，否则就返回false。 当返回false的时候，你可以用JSHint.errors来获取错误信息或者用JSHint.data()来获取lint的信息。 如果要了解更多，参见源代码。 使用JSHint，你可以在js文件的开始设定选项，例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*jshint evil:true, boss:true */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而设定global参数可以告诉JSHint，全局的变量配置。 例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*global DISQUS: true, jQuery: false */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上的这个例子是告诉JSHint,DISQUS是你自己声明的全局变量，而jQuery是你引入的全局变量&lt;/p&gt;

&lt;h3 id=&quot;jshintjslint&quot;&gt;JSHint和JSLint有什么区别？&lt;/h3&gt;

&lt;p&gt;JSHint是JSLint的一个分支（fork），他比JSLint更加的便捷。用来约束你的代码质量和编码风格。 每个人都有不一样的编码习惯和风格，JSHint通过配置可以适应于各种情况。 JSHint的适用环境&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;浏览器环境（browsers）&lt;/li&gt;
  &lt;li&gt;Node.js&lt;/li&gt;
  &lt;li&gt;jQuery&lt;/li&gt;
  &lt;li&gt;ES5&lt;/li&gt;
  &lt;li&gt;CouchDB&lt;/li&gt;
  &lt;li&gt;Prototype.js&lt;/li&gt;
  &lt;li&gt;Mootools.js&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jshint-3&quot;&gt;JSHint的选项配置&lt;/h3&gt;

&lt;h4 id=&quot;asi&quot;&gt;asi&lt;/h4&gt;

&lt;p&gt;如果是真，JSHint会无视没有加分号的行尾。自动补全分号一直是Javascript很有争议的一个语法特性。默认，JSHint会要求你在每个语句后面加上分号，但是如果你认为自己理解了asi(automatic semicolon insertion)，你可以抛弃JSHint对分号的检查。&lt;/p&gt;

&lt;h4 id=&quot;bitwise&quot;&gt;bitwise&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint会禁用位运算符。Javascript允许位运算，但是他却没有整型，位运算符要把参与运算的数字从浮点数变为整数，并在运算后再转换回来。这样他们的效率就不如在别的语言中那么高。&lt;/p&gt;

&lt;h4 id=&quot;boss&quot;&gt;boss&lt;/h4&gt;

&lt;p&gt;很霸气的选项，如果为真，那么JSHint会允许在if，for，while里面编写赋值语句。一般来说，我们会在循环、判断等语句中加入值的比较来做语句的运行条件，有时候会把==错写成赋值的=，通常，JSHint会把这个认定为一个错误，但是开启这个选项的话，JSHint就不会检查判断条件中的赋值 ，你是boss，你说的算:)。&lt;/p&gt;

&lt;h4 id=&quot;curly&quot;&gt;curly&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint会要求你在使用if和while等结构语句时加上{}来明确代码块。 Javascript允许在if等结构语句体只有一句的情况下不加括号。不过这样做可能会让你的代码读起来有些晦涩。&lt;/p&gt;

&lt;h4 id=&quot;debug&quot;&gt;debug&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint会允许代码中出现debugger的语句。不过建议你最好在检测代码前去掉debug的语句。&lt;/p&gt;

&lt;h4 id=&quot;eqeqeq&quot;&gt;eqeqeq&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint会看你在代码中是否都用了===或者是!==，而不是使用==和!=。 我们建议你在比较0，’‘(空字符)，undefined，null，false和true的时候使用===和!===。&lt;/p&gt;

&lt;h4 id=&quot;eqnull&quot;&gt;eqnull&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint会允许使用”== null”作比较。== null 通常用来判断一个变量是undefined或者是null（当时用==，null和undefined都会转化为false）。&lt;/p&gt;

&lt;h4 id=&quot;evil&quot;&gt;evil&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint会允许使用eval。eval提供了访问Javascript编译器的途径，这有时很有用，但是同时也对你的代码形成了注入攻击的危险，并且会对debug造成一些困难。 记住，Function构造函数也是另一个‘eval’，另外，当传入的参数是字符串的时候，setTimeout和setInterval也会类似于eval。&lt;/p&gt;

&lt;h4 id=&quot;forin&quot;&gt;forin&lt;/h4&gt;

&lt;p&gt;如果为真，那么，JSHint允许在for in 循环里面不出现hasOwnProperty。for in循环一般用来遍历一个对象的属性，这其中也包括他继承自原型链的属性，而hasOwnProperty可以来判断一个属性是否是对象本身的属性而不是继承得来的。&lt;/p&gt;

&lt;h4 id=&quot;immed&quot;&gt;immed&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint要求匿名函数的调用如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(){ // }());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而不是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(){ //bla bla })();
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;laxbreak&quot;&gt;laxbreak&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint则不会检查换行。Javascript会通过自动补充分号来修正一些错误，因此这个选项可以检查一些潜在的问题。&lt;/p&gt;

&lt;h4 id=&quot;maxerr&quot;&gt;maxerr&lt;/h4&gt;

&lt;p&gt;设定错误的阈值，超过这个阈值jshint不再向下检查，提示错误太多。&lt;/p&gt;

&lt;h4 id=&quot;newcap&quot;&gt;newcap&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint会要求每一个构造函数名都要大写字母开头。构造器是一种使用new运算符来创建对象的一种函数，new操作符会创建新的对象，并建立这个对象自己的this，一个构造函数如果不用new运算符来运行，那么他的this会指向全局对象而导致一些问题的发生。&lt;/p&gt;

&lt;h4 id=&quot;noarg&quot;&gt;noarg&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint会禁止arguments.caller和arguments.callee的使用 arguments对象是一个类数组的对象，它具有一个索引值。arguments.callee指向当前执行的函数（这个在ES5的严格模式中被禁用了），而arguments.caller指向调用当前函数的函数（如果有的话），并且，他并不是在所有的Javascript实现里面都有。&lt;/p&gt;

&lt;h4 id=&quot;noempty&quot;&gt;noempty&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint会禁止出现空的代码块（没有语句的代码块）。 如果为真，JSHint会禁用构造器，以避免一些问题。 在JSLint中会主动禁用构造器的方式以避免一些潜在问题，但其实很多构造器的使用并非有害，例如如下的调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new JsUIWindow(); //注意这个调用是没有把构造器的结果赋值给变量的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，我们需要使用构造器的时候可以禁用这个选项。&lt;/p&gt;

&lt;h4 id=&quot;nomen&quot;&gt;nomen&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint会禁用下划线的变量名。 很多人使用_name的方式来命名他们的变量，以说明这是一个私有变量，但实际上，并不是，下划线只是做了一个标识。 如果要使用私有变量，可以使用闭包来实现。&lt;/p&gt;

&lt;h4 id=&quot;onevar&quot;&gt;onevar&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint期望函数只被var的形式声明一遍。&lt;/p&gt;

&lt;h4 id=&quot;passfail&quot;&gt;passfail&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint会在发现首个错误后停止检查。&lt;/p&gt;

&lt;h4 id=&quot;plusplus&quot;&gt;plusplus&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint会禁用自增运算和自减运算 ++和–可能会带来一些代码的阅读上的困惑。&lt;/p&gt;

&lt;h4 id=&quot;regexp&quot;&gt;regexp&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint会不允许使用.和[^…]的正则， 因为这样的正则往往会匹配到你不期望的内容，并可能会应用造成一些危害。&lt;/p&gt;

&lt;h4 id=&quot;sub&quot;&gt;sub&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint会允许各种形式的下标来访问对象。 通常，JSHint希望你只是用点运算符来读取对象的属性（除非这个属性名是一个保留字），如果你不希望这样可以关闭这个选项。&lt;/p&gt;

&lt;h4 id=&quot;strict&quot;&gt;strict&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint会要求你使用use strict;语法。 Strict 模式是ES5里面的一个新特性，他允许你把一个程序或者函数放在一个“严格”的作用域中。可见Resig写的一篇关于严格模式的blog 严格模式做了几件事情:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;他可以捕获一些错误和异常&lt;/li&gt;
  &lt;li&gt;当我们进行一下“不安全”的操作时，他会抛异常，例如访问全局变量。&lt;/li&gt;
  &lt;li&gt;他会禁止你使用一些奇淫技巧，或者不良的代码编写。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;undef&quot;&gt;undef&lt;/h4&gt;

&lt;p&gt;如果为真，JSHint会要求所有的非全局变量，在使用前都被声明。 如果你不在一个本地作用域内使用var的方式来声明变量，Javascript会把它放到全局作用域下面。这样会很容易引起错误。&lt;/p&gt;

&lt;h4 id=&quot;white&quot;&gt;white&lt;/h4&gt;

&lt;p&gt;如果为true，JSHint会依据严格的空白规范检查你的代码。&lt;/p&gt;
</description>
        <pubDate>Tue, 29 Oct 2013 00:00:00 +0800</pubDate>
        <link>http://www.peigong.net/articles/lessons/jshint-instructions-for-use.html</link>
        <guid isPermaLink="true">http://www.peigong.net/articles/lessons/jshint-instructions-for-use.html</guid>
        
        <category>开发工具</category>
        
        
        <category>lessons</category>
        
      </item>
    
      <item>
        <title>使用JSDoc3生成javascript项目的API文档</title>
        <description>
&lt;h2 id=&quot;jsdoc&quot;&gt;JSDoc样式的注释&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;选用JSDoc3作为注释规范，文档生成工具使用grunt-jsdoc，本文不再介绍选型过程和原因。对JSDoc3的深入学习使用，可以参考&lt;a href=&quot;http://usejsdoc.org/index.html&quot;&gt;入门教程http://usejsdoc.org/index.html&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JSDoc注释的样式如下例，与单行注释 &lt;code&gt;//&lt;/code&gt; 和多行注释 &lt;code&gt;/**/&lt;/code&gt; 不同，而是类似于JAVA的JDoc和PHP的PHPDoc。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
* JSDoc注释。
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jsdoc-1&quot;&gt;JSDoc的常用标签&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;函数注释示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
* 函数注释的示例。
* @param {Integer} augend 被加数。
* @param {Integer} addend 加数。
* @return {Integer} 两数之和。
* @example
* add(1, 2) =&amp;gt; 3
*/
function add(augend, addend){
	return augend + addend;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;参数注释&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;@param&lt;/code&gt; 用于对函数、类的方法的参数进行注释，是JSDoc中最常用的注释标签。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@param&lt;/code&gt; 注释必须指定一个参数名，也可以有一个用大括号括起来的参数类型，以及参数的描述信息。参数类型可以是javascript内置的数据类型，如Array、Boolean、Date、Function、Number Object 、String 等，还可以是其他JSDoc所支持的（英文没看太懂，以后用到再认真学习）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The parameter type can be a built-in JavaScript type, such as string or Object, or a JSDoc namepath to another symbol in your code. If you have written documentation for the symbol at that namepath, JSDoc will automatically link to the documentation for that symbol. You can also use a type expression to indicate, for example, that a parameter is not nullable or can accept any type; see the @type documentation for details.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面直接使用&lt;a href=&quot;http://usejsdoc.org/tags-param.html&quot;&gt;http://usejsdoc.org/tags-param.html&lt;/a&gt;文档中的例子，说明 &lt;code&gt;@param&lt;/code&gt; 标签中如何使用参数名、参数类型和参数描述信息。&lt;/p&gt;

&lt;p&gt;只有参数名的注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param somebody
 */
function sayHello(somebody) {
    alert(&#39;Hello &#39; + somebody);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;包括参数名和参数类型的注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {string} somebody
 */
function sayHello(somebody) {
    alert(&#39;Hello &#39; + somebody);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;包括参数名、参数类型和参数描述的注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {string} somebody Somebody&#39;s name.
 */
function sayHello(somebody) {
    alert(&#39;Hello &#39; + somebody);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;返回值注释&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;@return&lt;/code&gt; 说明函数的返回值。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;@return {Number}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@return {Number} Sum of a and b&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@return {Number|Array} Sum of a and b or an array that contains a, b and the sum of a and b.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;参见：&lt;a href=&quot;http://usejsdoc.org/tags-returns.html&quot;&gt;http://usejsdoc.org/tags-returns.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;模块注释&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;@module&lt;/code&gt;标签用于标记当前代码文件属于哪个模块。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;@link&lt;/code&gt; 或 &lt;code&gt;@see&lt;/code&gt; 标签中，使用 &lt;code&gt;module:moduleName&lt;/code&gt; 可以链接到一个模块。例如，使用 &lt;code&gt;{@link module:foo/bar}&lt;/code&gt;，可以链接到由 &lt;code&gt;&quot;@module foo/bar&lt;/code&gt; 定义的模块。&lt;/p&gt;

&lt;p&gt;如果没有提供模块名，将使用模块文件所在路径及文件名作模块名。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;参考引用注释&lt;/h3&gt;

&lt;p&gt;&lt;code&gt; @see&lt;/code&gt; 标签可以指向一个相关的引用。示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Both of these will link to the bar function.
 * @see {@link bar}
 * @see bar
 */
function foo() {}

// Use the inline {@link} tag to include a link within a free-form description.
/**
 * @see {@link foo} for further information.
 * @see {@link http://github.com|GitHub}
 */
function bar() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;类的注释&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;@name&lt;/code&gt; ：类名称&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@class&lt;/code&gt; ：类描述&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@constructor&lt;/code&gt; ：表明这是一个构造函数，非常重要。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@extends&lt;/code&gt;	:类继承的父类。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@type&lt;/code&gt;	：数据的类型，主要用来注释属性。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@default&lt;/code&gt;	：默认值，主要用来注释属性。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@abstract&lt;/code&gt; 标明一个成员是抽象的，需要子类去实现。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@public&lt;/code&gt;、&lt;code&gt;@protected&lt;/code&gt;、&lt;code&gt;@private&lt;/code&gt;：类、方法或属性的访问权限&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;类的注释示例&lt;/h3&gt;

&lt;p&gt;要把JSDoc3的注释生成API类库文档，&lt;code&gt;@lends&lt;/code&gt; 是个很要紧的标签。&lt;/p&gt;

&lt;p&gt;例如，&lt;code&gt;@lends Sample.prototype&lt;/code&gt; 表示下面的对象归属于Sample。&lt;/p&gt;

&lt;p&gt;较详尽的使用说明参见&lt;a href=&quot;http://usejsdoc.org/tags-lends.html&quot;&gt;http://usejsdoc.org/tags-lends.html&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;有关类的定义和注释示例，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
* @name Sample
* @class 示例类
* @public
* @constructor
*/
function Sample(){
	this.something = [];
}

Sample.prototype = 
/** @lends Sample.prototype*/
{
	/**
	* 属性示例。
	* @private
	* @type {Array}
	* @default []
	*/
	something : [],

	/**
	* 方法示例。
	* @public
	* @param {String} arg 跟踪方法插件。
	*/
	doSomething: function(arg){
	}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-7&quot;&gt;其他常用注释&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;@example&lt;/code&gt;	: 示例代码。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;@enum [&amp;lt;type&amp;gt;]&lt;/code&gt;	: 一组同样类型的静态属性集合。&lt;code&gt;switch&lt;/code&gt; 语句中的分支应该只使用枚举。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@overview	&lt;/code&gt;	：对当前代码文件的描述。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@copyright&lt;/code&gt;	：代码的版权信息。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@author &amp;lt;name&amp;gt; [&amp;lt;emailAddress&amp;gt;]&lt;/code&gt;	：代码的作者信息。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@version&lt;/code&gt;		：当前代码的版本。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;readmemd-&quot;&gt;README.md 是很好的&lt;/h4&gt;

&lt;p&gt;如果你有为项目写说明文档的好习惯，碰巧又使用的是MarkDown格式，碰巧文件名又是README.md，那就很好了。&lt;/p&gt;

&lt;p&gt;把README.md文件放在代码清单里边，JSDoc工具是自动为你生成API文档的首页，什么系统概况、设计需求、设计方案及版本更新记录等等的内容都可以放进来。&lt;/p&gt;

&lt;h2 id=&quot;grunt&quot;&gt;Grunt自动构建的配置&lt;/h2&gt;

&lt;p&gt;Grunt的安装使用，请参考教程&lt;a href=&quot;http://clientlab.github.io/lessons/2013/10/15/installation-and-use-of-grunt/&quot;&gt;《Grunt的安装和使用》&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;JSDoc某些配置有git依赖， 需要在命令行中可以执行git命令。最好先安装一个msysgit(http://msysgit.github.io/)，然后在环境变量中增加git的bin目录。&lt;/p&gt;

&lt;p&gt;使用JSDoc3插件，在package.json中的NPM依赖配置参考，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;devDependencies&quot;: {
	... ...
	&quot;grunt-jsdoc&quot;: &quot;~0.5.4&quot;,
	&quot;ink-docstrap&quot;: &quot;~0.3.0&quot;,
	... ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用JSDoc3插件，在Gruntfile中的配置参考，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jsdoc: {
  dist : {
      src: [&#39;README.md&#39;, &#39;src/sample.js&#39;], 
      options: {
        destination: &#39;api&#39;,
        template: &quot;libs/jsdoc3/docstrap/template&quot;,
        configure: &quot;libs/jsdoc3/docstrap/template/jsdoc.conf.json&quot;            
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细使用方法和参数，参考：&lt;a href=&quot;https://github.com/krampstudio/grunt-jsdoc-plugin&quot;&gt;https://github.com/krampstudio/grunt-jsdoc-plugin&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://usejsdoc.org/index.html&quot;&gt;JSDoc 主页&lt;/a&gt; - &lt;a href=&quot;https://github.com/jsdoc3/jsdoc&quot;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;grunt-jsdoc-plugin Grunt任务插件 &lt;a href=&quot;https://npmjs.org/package/grunt-jsdoc&quot;&gt;NPM&lt;/a&gt; - &lt;a href=&quot;https://github.com/krampstudio/grunt-jsdoc-plugin&quot;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/terryweiss/docstrap&quot;&gt;JSDoc模板docstrap&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.36ria.com/5101&quot;&gt;使用jsdoc生成组件API文档—jsdoc实战&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 24 Oct 2013 00:00:00 +0800</pubDate>
        <link>http://www.peigong.net/articles/lessons/build-api-document-by-jsdoc3.html</link>
        <guid isPermaLink="true">http://www.peigong.net/articles/lessons/build-api-document-by-jsdoc3.html</guid>
        
        <category>开发工具</category>
        
        
        <category>lessons</category>
        
      </item>
    
  </channel>
</rss>
